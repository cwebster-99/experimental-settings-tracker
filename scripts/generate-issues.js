/**
 * Generate GitHub issues for experimental settings tracking
 * Creates 2 issues:
 *   1. Experimental settings that have been experimental for >60 days
 *   2. Recently added experimental settings (last 28 days)
 *
 * Uses the GitHub CLI (gh) to create issues in the repository.
 */

import { readFile, writeFile, unlink } from 'fs/promises';
import { execFile } from 'child_process';
import { promisify } from 'util';
import { tmpdir } from 'os';
import { join } from 'path';

const execFileAsync = promisify(execFile);

const FOUND_SETTINGS_FILE = process.env.FOUND_SETTINGS_FILE || './found-settings.json';
const DAYS_BACK = parseInt(process.env.REPORT_DAYS || '28', 10);
const FLAGGED_THRESHOLD = 60;
const REPO = process.env.GITHUB_REPO || 'cwebster-99/experimental-settings-tracker';

/**
 * Load JSON file
 */
async function loadJsonFile(filePath) {
    const content = await readFile(filePath, 'utf-8');
    return JSON.parse(content);
}

/**
 * Compute age in days from a date string
 */
function ageInDays(dateString) {
    if (!dateString) return null;
    return Math.floor((Date.now() - new Date(dateString).getTime()) / (24 * 60 * 60 * 1000));
}

/**
 * Get author name from a setting object
 */
function getAuthor(setting) {
    return (setting.addedBy && setting.addedBy.name) ||
           (setting.owner && setting.owner.name) || 'Unknown';
}

/**
 * Escape pipe characters for markdown table cells
 */
function esc(str) {
    if (!str) return '';
    return String(str).replace(/\|/g, '\\|');
}

/**
 * Build the flagged settings (>60 days) issue body
 */
function buildFlaggedIssueBody(flagged, totalCount, dateStr) {
    const lines = [
        `## Experimental Settings: Older than ${FLAGGED_THRESHOLD} Days`,
        '',
        `> Auto-generated on ${dateStr}`,
        '',
        `**${flagged.length}** settings have been marked as experimental for more than ${FLAGGED_THRESHOLD} days (out of **${totalCount}** total experimental settings).`,
        '',
        'These settings should be reviewed to determine if they should be:',
        '- **Graduated** to stable (remove experimental tag)',
        '- **Removed** if the experiment is no longer needed',
        '- **Kept** as experimental with a justification',
        '',
        '| Setting | Added | Age (days) | Owner | Area |',
        '|---------|-------|------------|-------|------|',
    ];

    for (const s of flagged) {
        lines.push(`| \`${esc(s.name)}\` | ${s.addedDate} | ${s.age} | ${esc(s.author)} | ${s.area} |`);
    }

    lines.push('');
    lines.push('---');
    lines.push(`*Auto-generated by experimental-settings-tracker*`);

    return lines.join('\n');
}

/**
 * Build the recently added settings issue body
 */
function buildRecentIssueBody(recent, totalCount, dateStr) {
    const lines = [
        `## Recently Added Experimental Settings (Last ${DAYS_BACK} Days)`,
        '',
        `> Auto-generated on ${dateStr}`,
        '',
        `**${recent.length}** new experimental settings were added in the last ${DAYS_BACK} days (total: **${totalCount}**).`,
        '',
        '| Setting | Added | Author | Area | Tags |',
        '|---------|-------|--------|------|------|',
    ];

    for (const s of recent) {
        const tags = s.tags && s.tags.length > 0 ? s.tags.map(t => `\`${t}\``).join(', ') : '-';
        lines.push(`| \`${esc(s.name)}\` | ${s.addedDate} | ${esc(s.author)} | ${s.area} | ${tags} |`);
    }

    lines.push('');
    lines.push('---');
    lines.push(`*Auto-generated by experimental-settings-tracker*`);

    return lines.join('\n');
}

/**
 * Close previous auto-generated issues with matching title prefix
 */
async function closePreviousIssues(titlePrefix) {
    try {
        const { stdout } = await execFileAsync('gh', [
            'issue', 'list',
            '--repo', REPO,
            '--state', 'open',
            '--search', `"${titlePrefix}" in:title`,
            '--json', 'number,title',
            '--limit', '50'
        ]);

        const issues = JSON.parse(stdout || '[]');
        for (const issue of issues) {
            if (issue.title.startsWith(titlePrefix)) {
                console.log(`   Closing previous issue #${issue.number}: ${issue.title}`);
                await execFileAsync('gh', [
                    'issue', 'close', String(issue.number),
                    '--repo', REPO,
                    '--reason', 'completed',
                    '--comment', 'Superseded by new report.'
                ]);
            }
        }
    } catch (error) {
        // No previous issues or gh not authenticated - continue
        console.log(`   Note: Could not check previous issues: ${error.message}`);
    }
}

/**
 * Create a GitHub issue via gh CLI using a temp file for the body
 */
async function createIssue(title, body, labels) {
    const tmpFile = join(tmpdir(), `gh-issue-${Date.now()}.md`);
    try {
        await writeFile(tmpFile, body, 'utf-8');

        const args = [
            'issue', 'create',
            '--repo', REPO,
            '--title', title,
            '--body-file', tmpFile,
        ];

        for (const label of labels) {
            args.push('--label', label);
        }

        const { stdout } = await execFileAsync('gh', args);
        return stdout.trim();
    } finally {
        try { await unlink(tmpFile); } catch { /* ignore */ }
    }
}

/**
 * Main function
 */
async function generateIssues() {
    const dateStr = new Date().toISOString().split('T')[0];

    console.log('üìã Generating GitHub Issues for Experimental Settings');
    console.log('='.repeat(55));

    // Load settings data
    const findings = await loadJsonFile(FOUND_SETTINGS_FILE);
    const totalCount = findings.settings.length;

    // Compute flagged (>60 days) and recent (<=28 days) settings
    const flagged = [];
    const recent = [];

    for (const s of findings.settings) {
        const date = s.addedDate || (s.owner && s.owner.date);
        if (!date) continue;
        const age = ageInDays(date);
        if (age === null) continue;

        // Skip invalid settings (no dot = structural key, not a real setting)
        if (!s.name.includes('.')) continue;

        const entry = {
            name: s.name,
            addedDate: date,
            age,
            author: getAuthor(s),
            area: s.area || s.name.split('.').slice(0, 2).join('.'),
            tags: s.tags
        };

        if (age > FLAGGED_THRESHOLD) flagged.push(entry);
        if (age <= DAYS_BACK) recent.push(entry);
    }

    // Sort flagged by age descending, recent by date descending
    flagged.sort((a, b) => b.age - a.age);
    recent.sort((a, b) => new Date(b.addedDate) - new Date(a.addedDate));

    console.log(`\n   Flagged (>${FLAGGED_THRESHOLD} days): ${flagged.length}`);
    console.log(`   Recent (last ${DAYS_BACK} days): ${recent.length}`);

    // --- Issue 1: Flagged settings (>60 days) ---
    const flaggedTitle = `[Report] Experimental settings older than ${FLAGGED_THRESHOLD} days - ${dateStr}`;
    const flaggedBody = buildFlaggedIssueBody(flagged, totalCount, dateStr);

    console.log(`\nüìå Creating issue: ${flaggedTitle}`);
    try {
        await closePreviousIssues(`[Report] Experimental settings older than ${FLAGGED_THRESHOLD} days`);
        const url1 = await createIssue(flaggedTitle, flaggedBody, ['report', 'flagged']);
        console.log(`   ‚úÖ Created: ${url1}`);
    } catch (error) {
        console.error(`   ‚ùå Failed to create flagged issue: ${error.message}`);
    }

    // --- Issue 2: Recently added settings ---
    const recentTitle = `[Report] Recently added experimental settings - ${dateStr}`;
    const recentBody = buildRecentIssueBody(recent, totalCount, dateStr);

    console.log(`\nüìå Creating issue: ${recentTitle}`);
    try {
        await closePreviousIssues(`[Report] Recently added experimental settings`);
        const url2 = await createIssue(recentTitle, recentBody, ['report', 'new-settings']);
        console.log(`   ‚úÖ Created: ${url2}`);
    } catch (error) {
        console.error(`   ‚ùå Failed to create recent issue: ${error.message}`);
    }

    console.log('\n‚úÖ Issue generation complete.');
}

// Run if called directly
generateIssues()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(`\n‚ùå Error: ${error.message}`);
        process.exit(1);
    });
